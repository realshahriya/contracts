// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/HYPEYToken.sol";
import "../src/HYPEYTreasury.sol";
import "../src/HypeyVesting.sol";

/**
 * @title VulnerabilityTests
 * @dev Test suite to demonstrate critical security vulnerabilities
 */
contract VulnerabilityTests is Test {
    HYPEYToken public token;
    HYPEYTreasury public treasury;
    HypeyVesting public vesting;
    
    address public owner = address(0x1);
    address public attacker = address(0x2);
    address public victim = address(0x3);
    address public timelock = address(0x4);
    
    uint256 constant INITIAL_SUPPLY = 1_000_000_000 * 10**18;
    
    function setUp() public {
        vm.startPrank(owner);
        
        // Deploy contracts
        token = new HYPEYToken();
        treasury = new HYPEYTreasury();
        vesting = new HypeyVesting();
        
        // Initialize contracts
        token.initialize(address(treasury), timelock, owner);
        treasury.initialize(address(token), timelock, owner);
        vesting.initialize(address(token), timelock, owner);
        
        vm.stopPrank();
    }
    
    /**
     * @dev Test 1: Reentrancy Attack on Token Transfer
     */
    function testReentrancyAttack() public {
        // Setup: Give attacker some tokens
        vm.prank(owner);
        token.transfer(attacker, 1000 * 10**18);
        
        // Deploy malicious contract
        MaliciousReceiver malicious = new MaliciousReceiver(address(token));
        
        // Set malicious contract as reserve burn address
        vm.prank(owner);
        token.setReserveBurnAddress(address(malicious));
        
        // Attacker initiates transfer that triggers reentrancy
        vm.prank(attacker);
        vm.expectRevert(); // Should revert due to reentrancy, but currently doesn't
        token.transfer(victim, 100 * 10**18);
        
        // Check if reentrancy was successful (balance manipulation)
        assertGt(malicious.attackCount(), 0, "Reentrancy attack should have been attempted");
    }
    
    /**
     * @dev Test 2: Front-running Night Mode Change
     */
    function testFrontRunningNightMode() public {
        // Setup DEX pair
        address dexPair = address(0x5);
        vm.prank(owner);
        token.setDexPair(dexPair);
        
        // Give victim tokens
        vm.prank(owner);
        token.transfer(victim, 1000 * 10**18);
        
        // Victim prepares to sell during day mode (4% tax)
        vm.prank(victim);
        token.approve(dexPair, 500 * 10**18);
        
        // Check current tax rate (should be day rate)
        uint256 dayTax = token.DAY_SELL_TAX_BPS();
        assertEq(dayTax, 400, "Day tax should be 4%");
        
        // Owner front-runs by switching to night mode (16% tax)
        vm.prank(owner);
        token.setNightMode(true);
        
        // Simulate victim's transaction executing with higher tax
        uint256 balanceBefore = token.balanceOf(victim);
        vm.prank(dexPair); // Simulate DEX calling transferFrom
        token.transferFrom(victim, dexPair, 500 * 10**18);
        
        uint256 balanceAfter = token.balanceOf(victim);
        uint256 actualTax = balanceBefore - balanceAfter - 500 * 10**18;
        
        // Victim paid night tax instead of expected day tax
        uint256 expectedDayTax = (500 * 10**18 * dayTax) / 10000;
        uint256 nightTax = (500 * 10**18 * token.NIGHT_SELL_TAX_BPS()) / 10000;
        
        assertGt(actualTax, expectedDayTax, "Victim paid more tax than expected");
        assertEq(actualTax, nightTax, "Victim paid night tax rate");
    }
    
    /**
     * @dev Test 3: Daily Limit Bypass
     */
    function testDailyLimitBypass() public {
        // Fund treasury
        vm.deal(address(treasury), 10 ether);
        
        uint256 dailyLimit = treasury.DAILY_WITHDRAWAL_LIMIT();
        uint256 singleWithdrawal = dailyLimit - 1; // Just under limit
        
        // Admin makes multiple withdrawals just under the limit
        vm.startPrank(owner);
        
        // First withdrawal - should succeed
        treasury.disburseETH(owner, singleWithdrawal);
        
        // Second withdrawal - should also succeed (vulnerability)
        treasury.disburseETH(owner, singleWithdrawal);
        
        vm.stopPrank();
        
        // Check total withdrawn exceeds daily limit
        uint256 today = block.timestamp / 1 days;
        uint256 totalWithdrawn = treasury.dailyETHWithdrawals(today);
        
        assertGt(totalWithdrawn, dailyLimit, "Total withdrawals should exceed daily limit");
    }
    
    /**
     * @dev Test 4: Admin Privilege Abuse
     */
    function testAdminPrivilegeAbuse() public {
        // Give victim tokens
        vm.prank(owner);
        token.transfer(victim, 1000 * 10**18);
        
        // Owner exempts themselves from burns
        vm.prank(owner);
        token.setExemptFromBurn(owner, true);
        
        // Owner sets maximum burn rate
        vm.prank(owner);
        token.setBurnRate(300); // 3% maximum
        
        // Owner transfer has no burn
        uint256 ownerBalanceBefore = token.balanceOf(owner);
        vm.prank(owner);
        token.transfer(victim, 100 * 10**18);
        uint256 ownerBalanceAfter = token.balanceOf(owner);
        
        assertEq(ownerBalanceBefore - ownerBalanceAfter, 100 * 10**18, "Owner should have no burn");
        
        // Victim transfer has maximum burn
        uint256 victimBalanceBefore = token.balanceOf(victim);
        vm.prank(victim);
        token.transfer(owner, 100 * 10**18);
        uint256 victimBalanceAfter = token.balanceOf(victim);
        
        uint256 burnAmount = (100 * 10**18 * 300) / 10000;
        assertEq(victimBalanceBefore - victimBalanceAfter, 100 * 10**18 + burnAmount, "Victim should pay burn");
    }
    
    /**
     * @dev Test 5: Vesting Schedule Manipulation
     */
    function testVestingManipulation() public {
        // Create vesting schedule for victim
        vm.prank(owner);
        vesting.createVestingSchedule(
            victim,
            1000 * 10**18, // total amount
            block.timestamp, // start
            30 days, // cliff
            365 days, // duration
            1 days, // slice period
            1000 // 10% cliff unlock
        );
        
        // Fast forward past cliff
        vm.warp(block.timestamp + 31 days);
        
        // Victim should be able to claim some tokens
        uint256 claimable = vesting.computeReleasableAmount(victim, 0);
        assertGt(claimable, 0, "Should have claimable tokens");
        
        // Owner maliciously modifies schedule (if possible)
        // This demonstrates the risk of mutable vesting schedules
        vm.prank(owner);
        // Note: Current implementation doesn't allow modification,
        // but shows the risk if it did
        
        // Test shows need for immutable vesting schedules
    }
    
    /**
     * @dev Test 6: Integer Overflow in Burn Calculation
     */
    function testIntegerOverflow() public {
        // This test would demonstrate overflow issues if SafeMath wasn't used
        // or if there were calculation errors
        
        uint256 largeAmount = type(uint256).max / 2;
        uint256 largeTaxRate = 5000; // 50%
        
        // This calculation could overflow without proper protection
        vm.expectRevert(); // Should revert on overflow
        uint256 burnAmount = (largeAmount * largeTaxRate) / 10000;
        
        // Test demonstrates need for overflow protection
    }
    
    /**
     * @dev Test 7: Gas Limit DoS Attack
     */
    function testGasLimitDoS() public {
        // Add maximum number of supported tokens
        vm.startPrank(owner);
        
        for (uint256 i = 0; i < 50; i++) {
            address fakeToken = address(uint160(i + 1000));
            treasury.addSupportedToken(fakeToken);
        }
        
        vm.stopPrank();
        
        // Try to get supported tokens list (could run out of gas)
        address[] memory tokens = treasury.getSupportedTokens();
        assertEq(tokens.length, 50, "Should have 50 tokens");
        
        // Removing a token becomes expensive O(n) operation
        uint256 gasBefore = gasleft();
        vm.prank(owner);
        treasury.removeSupportedToken(address(1000));
        uint256 gasUsed = gasBefore - gasleft();
        
        // Gas usage increases linearly with array size
        assertGt(gasUsed, 10000, "Should use significant gas for removal");
    }
}

/**
 * @dev Malicious contract for reentrancy attack
 */
contract MaliciousReceiver {
    HYPEYToken public token;
    uint256 public attackCount;
    bool public attacking;
    
    constructor(address _token) {
        token = HYPEYToken(_token);
    }
    
    receive() external payable {
        if (!attacking && attackCount < 3) {
            attacking = true;
            attackCount++;
            
            // Attempt reentrancy
            try token.transfer(address(this), 1) {
                // Reentrancy successful
            } catch {
                // Reentrancy blocked
            }
            
            attacking = false;
        }
    }
    
    function onTokenReceived(address, uint256) external {
        // This could be called during token transfers
        if (!attacking && attackCount < 3) {
            attacking = true;
            attackCount++;
            
            // Attempt to manipulate state during transfer
            try token.transfer(msg.sender, 1) {
                // Attack successful
            } catch {
                // Attack blocked
            }
            
            attacking = false;
        }
    }
}